import { randomBytes } from 'crypto';
import {
  toBuffer,
  hashPersonalMessage,
  fromRpcSig,
  ecrecover,
  publicToAddress,
  bufferToHex,
} from 'ethereumjs-util';
import AuthError from '../errors/AuthError';
import AuthService, { AuthServiceOptions } from './AuthService';

export default class MetamaskAuthService extends AuthService {
  constructor(options: AuthServiceOptions) {
    super(options);
  }

  /**
   * Generate a secure random nonce for Metamask authentication
   * @returns A promise that resolves to a generated nonce
   */
  protected async generateMetamaskNonce() {
    return new Promise<string>((resolve, reject) => {
      randomBytes(128, (err, buf) => {
        if (err) reject(new AuthError('METAMASK/NONCE_GEN', err));
        resolve(buf.toString('hex'));
      });
    });
  }

  /**
   * Create a message containing the nonce for the user to sign
   * @param nonce Generated random nonce
   * @returns Message containing the nonce for the user to sign
   */
  private getMetamaskSignMessage(nonce: string | number) {
    if (typeof nonce === 'number') nonce = nonce.toString();
    return 'I am signing my one-time nonce: ' + nonce;
  }

  /**
   * Elliptic curve signature verification of user signature
   * @param publicAddress Metamask wallet address
   * @param nonce Random nonce generated by Sigmate backend, from DB
   * @param signature Signed message from user
   * @returns True if signature is verified, false otherwise
   */
  private verifyMetamaskSignature(
    publicAddress: string,
    nonce: string | number,
    signature: string
  ) {
    try {
      // Derive address from signature
      const msg = this.getMetamaskSignMessage(nonce);
      const msgHash = hashPersonalMessage(toBuffer(Buffer.from(msg, 'utf-8')));
      const { v, r, s } = fromRpcSig(signature);
      const publicKey = ecrecover(msgHash, v, r, s);
      const derivedPublicAddress = bufferToHex(publicToAddress(publicKey));

      // Compare it with given publicAddress
      return publicAddress.toLowerCase() === derivedPublicAddress.toLowerCase();
    } catch (error) {
      throw new AuthError('METAMASK/VERIFY', error);
    }
  }

  /**
   * Generate a random nonce for a user and return the nonce
   * If it is a new user, create a new user
   * @param metamaskWallet Metamask wallet address
   * @returns Generated random nonce for the user to sign
   */
  public async getMetamaskNonce(metamaskWallet: string) {
    if (!metamaskWallet) throw new AuthError('USER/UNAUTHENTICATED');
    await this.user.find({ metamaskWallet }, { set: true });
    if (!this.user) {
      // New user
      await this.signup({ metamaskWallet });
    } else {
      // Returning user
      if (!this.user.model?.auth) throw new AuthError('USER/UNAUTHENTICATED');
      const nonce = await this.generateMetamaskNonce();
      await this.user.update({ metamaskNonce: nonce });
      return nonce;
    }
  }

  /**
   * Verify the user's signature authenticate the user
   * On success, set the user attribute of this Auth instance
   * @param dto Object containing wallet address and signed message
   */
  public async authenticate(
    method: sigmate.Auth.AuthMethod,
    dto: sigmate.Auth.AuthDTO
  ) {
    if (method !== 'metamask' || !dto.metamask)
      throw new AuthError('METAMASK/METHOD');
    const { metamaskWallet, signature } = dto.metamask;
    if (!metamaskWallet) throw new AuthError('METAMASK/WALLET');
    if (!signature) throw new AuthError('METAMASK/SIGNATURE');
    await this.user.find({ metamaskWallet }, { set: true });
    if (!this.user.model?.auth) throw new AuthError('USER/UNAUTHENTICATED');
    const nonce = this.user.model.auth.metamaskNonce;
    if (!nonce) throw new AuthError('METAMASK/NONCE');

    const verified = this.verifyMetamaskSignature(
      metamaskWallet,
      nonce,
      signature
    );
    if (verified) {
      if (!this.user.model.isMetamaskVerified) {
        await this.user.update({ isMetamaskVerified: true });
      }
    } else {
      throw new AuthError('USER/UNAUTHENTICATED');
    }
  }
}
